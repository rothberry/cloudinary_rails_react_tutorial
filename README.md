# Phase 5, Lesson 8 Image Uploads to Cloudinary

- Setting up a Cloudinary account and configuring a new signed upload preset
- Configuring rails to sign upload requests
- Configuring react to add Cloudinary's upload widget and to persist the uploaded image to our api upon success

## Tasks

- We need to create a new signed upload preset on our cloudinary account. 
    - When we make an upload, we'll specify the preset in our client side code and it will apply the [transformations](https://cloudinary.com/documentation/image_transformations) that we specify to the image (cropping, resizing, compressing or adding effects or filters if we want)
- We need to grab our `cloud_name` as well so we can use it when we add the upload widget to our React client.
- We need to add database columns to store the image urls generated by cloudinary upon upload.
- We need to install dependencies
    - `cloudinary` and `dotenv-rails` gems for rails
    - `@cloudinary/url-gen` and `@cloudinary/react`  for the client
- We need to create a file called `.env` and add it to our `.gitignore` file so we can add our cloudinary credentials to it and keep them out of version control 
- We need to create an uploads controller to handle creating a signature that cloudinary will require before allowing the upload. 
    - This API endpoint will be protected (requiring authentication) so non-logged in users will not be able to upload to our cloudinary account. 
    - It will also allow us to keep our API_SECRET out of version control and out of our client side code. This will ensure that users can't look at our source code and use that information to upload images directly to our cloudinary account, they'll need to go through our API server first.
- We need to add an endpoint that can handle persisting an uploaded image's url (returned from cloudinary) to our backend api & database.
- We'll need to update our `UserSerializer` so that the image urls we just added will be included in the JSON response.
- We'll also create a React component that will handle opening the Cloudinary upload Widget that accepts props we can use to customize:
    - which upload preset should be used to process the image
    - what the button text should be, and
    - what should happen with the uploaded image
- We'll use the widget to handle uploading a profile picture to our account.

## Creating an Upload Preset

- In the cloudinary console, we need to visit settings/upload.
    - click the gear at the top right of the navbar and then select the Upload tab below the Settings header.
- Scroll down to the section that says **Upload presets** and find and click the link that says 'Add upload preset'
- make sure the **Signing Mode** is set to `signed`
- for the **Folder**, fill in `meetup_clone_profile_pictures`
- In the sidebar, select 'Upload Manipulations' 
- Set **Format** to `jpg`
- Below **Incoming Transformations**, click 'Edit'
    - A modal will appear, within it adjust the **width** and **height** you want to crop the image to. In our case, we want a square image, so both width and height should be the same. I'll use `600`.
    - This transformation will run on the image **before** it is saved to cloudinary.
    - For **Mode**, choose `Fill`
    - This will add a few more choices, for **Gravity**, choose: `Faces`
        - this will center the cropped image on the faces detected in the uploaded profile picture
    - You can read more about the [image transformation options for cropping and resizing here](https://cloudinary.com/documentation/resizing_and_cropping)
    - Click OK to save these settings
- Below **Eager Transofrmations** click the button to **Add Eager Transformation**
    - We'll use this one to create an icon sized version of the image that will show up in our Navbar
    - Set **Width** to `60`, **Height** to `60`, **Mode** to `Fill`, and **Gravity** to `Faces`
    - This will create another smaller version of the image that will be returned when we get a response from Cloudinary after uploading from the react client
- Click the orange 'Save' button to ensure your transformations are saved to the preset

## Installing Dependencies
```
bundle add cloudinary dotenv-rails
```

```
npm i --prefix client @cloudinary/url-gen @cloudinary/react --save
```

Add this script to the bottom of the public/index.html file:

```html
<script
  src="https://widget.cloudinary.com/v2.0/global/all.js"
  type="text/javascript"
></script>
```
## Adding credentials to .env
Create a file called `.env` at the root of the project
```
touch .env
```
Copy the credentials from your cloudinary api dashboard and put them into the `.env` file on separte lines like this:
```
CLOUDINARY_API_KEY=yourapikeywithnoquotesgoeshere
CLOUDINARY_API_SECRET=yourapisecretwithnoquotesgoeshere
```

If you open up rails console and type in `ENV['CLOUDINARY_API_KEY']` you should see the value stored in this file.

## Adding Columns for image urls to the Database

For our application, we're going to allow users to upload a profile picture. When they do, we'll store the url from cloudinary in our database. We're also going to store a thumbnail version of the image, so we'll have two columns for that.

This time I'm also going to try storing the public ID of the image so we can experiment with the React cloudinary library for triggering transformations client side if we have time!

```
rails g migration AddImageUrlsToUsers profile_picture_url profile_picture_thumbnail_url cloudinary_public_id
```

we should see something like this:

```
class AddImageUrlsToUsers < ActiveRecord::Migration[6.1]
  def change
    add_column :users, :profile_picture_thumbnail_url, :string
    add_column :users, :profile_picture_url, :string
    add_column :users, :cloudinary_public_id, :string
  end
end
```
We can run `rails db:migrate` to update our database schema.

## Creating the UploadsController

```
rails g controller api/uploads prepare
```

app/controllers/api/uploads_controller.rb
```rb
class Api::UploadsController < ApplicationController
  def prepare
    signature = Cloudinary::Utils.api_sign_request(params_to_sign, ENV['CLOUDINARY_API_SECRET'])
    render json: {
      signature: signature,
      api_key: ENV['CLOUDINARY_API_KEY'],
      upload_params: params_to_sign
    }
  end

  private

  def params_to_sign
    params.permit(:timestamp, :source, :upload_preset).to_h
  end
end
```

The signature created here will be valid for an hour and Cloudinary will require it to be present when we send the request to upload the image. Because this controller inherits from our `ApplicationController`, `confirm_authentication` will be called first, ensuring only authenticated users will able to upload to our cloudinary account.

Because we're sending data from the client and we don't want it to be visible in the url, we need to make this a `POST` request, so go into the routes and change 
```
get 'uploads/prepare'
```
to 
```
post 'uploads/prepare'
```

And while we're at it, we can move it into the api namespace that's already created in the routes file.

## Adding an endpoint for updating a User account (to add profile picture)

in config/routes.rb, add the following within the api namespace.

```rb
patch "/me", to: "users#update"
```

And then add the action to the `UsersController`

```rb
class Api::UsersController < ApplicationController
  skip_before_action :confirm_authentication, except: [:update]
  # ...
  def update
    if current_user.update(update_user_params)
      render json: current_user, status: :ok
    else 
      render json: user.errors, status: :unprocessable_entity
    end
  end

  private

  # ...

  def update_user_params
    params.permit(:profile_picture_url, :profile_picture_thumbnail_url)
  end
end
```

We want the authentication check before we update the profile, so we add an except to the `skip_before_action` call. We're allowing the `profile_picture_url` and the `profile_picture_thumbnail_url` to come from the client through params. These urls will be taken from the response from the cloudinary api. 

>**NOTE**: This means transformations will only happen on upload. If we want to use cloudinary transitions more heavily, we can also apply them on the fly from our react code using methods and plugins provided by the cloudinary react packages. In order to support that, we would persist the `public_id` of the image to the database instead of the url. This would allow us to use cloudinary transformations from our react code. The free plan only allows a limited number of transformations per month-25000 max I believe-so this trade off is fine with me for now!

Before we move on, one more thing we need to think about. When we get the current user back from the `/me` endpoint, we won't have the image urls we just added, so we need to add a `UserSerializer` to include those and also to skip sending the password_digest to the client!

```bash
bundle add active_model_serializers
```

```bash
rails g serializer User username profile_picture_thumbnail_url profile_picture_url cloudinary_public_id
```

```rb
class UserSerializer < ActiveModel::Serializer
  attributes :id, :username, :profile_picture_thumbnail_url, :profile_picture_url, :cloudinary_public_id
end
```

## Creating the `CloudinaryUpload` component

We're adding 3 props here: `preset`, `handleUpload` and `buttonText`. 

The `preset` allows us to use the upload widget with multiple upload presets on Cloudinary (so we can apply different transformations/limits in different situations). 

The `handleUpload` function is a callback that will be invoked after we get a successful upload response from cloudinary. This will allow us to persist the image data to our own api with another fetch request.

Finally, the `buttonText` allows us to use  different text content for the button that will trigger the upload widget in different situations. For our case, it will be 'Add Profile Picture' when we use the component; but, for events, it would be something like 'Add Event Poster.'

```js
// client/src/components/CloudinaryUpload.js
import React, { useEffect } from "react";

function CloudinaryUpload({
  preset,
  handleUpload,
  buttonText
}) {

  // this function will generate an id to be used in
  // targeting the element to which we'll add a click event
  // listener to trigger the upload widget to appear.
  // We're generating the id based on the button text
  // so that we'll be able to have multiple buttons with
  // different upload presents visible on the same page.
  const generateId = () => {
    const ending = buttonText.split(' ').map(w => w.toLowerCase()).join('_')
    return `upload_widget_${ending}`
  }
  
  useEffect(() => {
    window.myWidget = window.cloudinary.createUploadWidget(
      {
        cloudName: "dpkrqs9rs",
        uploadPreset: preset,
        prepareUploadParams: (cb, params) => {
          params = [].concat(params);  //params can be a single object or an array of objects
          Promise.all(params.map((body) => {
            return fetch("/api/uploads/prepare", {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json'
              },
              body: JSON.stringify(body)
            })
              .then(res => res.json())
          }))
            .then((results) =>
              cb(results.length === 1 ? results[0] : results)
            );
        }
      },
      (error, result) => {
        if (!error && result && result.event === "success") {
          console.log("Done! Here is the image info: ", result.info);
          handleUpload && handleUpload(result);
          window.myWidget.close();
        }
      }
    );
    document.getElementById(generateId()).addEventListener(
      "click",
      function () {
        window.myWidget.open();
      },
      false
    );
  }, [preset, handleUpload]);

  return (
    <a href="#" id={generateId()}>
      {buttonText}
    </a>
  );
}

export default CloudinaryUpload;
```

the `prepareUploadParams` option inside of the first argument passed to the `createUploadWidget` method is how cloudinary will sign the request to make sure that the user making the upload request has the proper permissions. This function will make a request to our api with the upload parameters in the body and use the response to invoke a callback that will complete the upload if the signature checks out. After that, the second argument to the `createUploadWidget` method is a callback function to handle the response from cloudinary. Upon the successful upload so we can persist the urls to our api by invoking the `handleUpload` function passed as a prop to `CloudinaryUpload`.

## Adding the Upload Widget to our Profile Component
Here, we'll need to pass the proper preset as a prop
```js
// client/src/components/Profile.js
import React from 'react'
import CloudinaryUpload from './CloudinaryUpload'

function Profile({currentUser, setCurrentUser}) {
  const handleUpload = (result) => {
    const body = {
      profile_picture_url: result.info.secure_url,
      profile_picture_thumbnail_url: result.info.eager[0].secure_url,
      cloudinary_public_id: 'fill me in'
    }
    fetch('/api/me', {
      method: 'PATCH',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify(body)
    })
      .then(res => res.json())
      .then(user => {
        console.log(user);
        setCurrentUser(user)
      })
  }

  return (
    <div className="grid sm:grid-cols-3 gap-4">
      <div className="">
        <img src={currentUser.profile_picture_url || "https://res.cloudinary.com/dpkrqs9rs/image/upload/v1637085098/Profile_avatar_placeholder_large_ky4gfw.png"} />
        <CloudinaryUpload
          preset="tl8ilpaq"
          buttonText="Update Profile Picture"
          handleUpload={handleUpload}
        /> 
      </div>
      <div className="col-span-2">
        <h2 className="text-xl">{currentUser.username}</h2>
      </div>
    </div>
  )
}

export default Profile
```

## Resources

- [Cloudinary React integration](https://cloudinary.com/documentation/react2_integration)
- [Cloudinary Ruby Utility for Signing Requests](https://cloudinary.com/documentation/cloudinary_cli#examples-4)
- [Cloudinary Rails - Direct Uploading from the browser](https://cloudinary.com/documentation/rails_image_and_video_upload#direct_uploading_from_the_browser)
- [Cloudinary upload widget 2.0](https://support.cloudinary.com/hc/en-us/articles/360009420291-How-To-Migrate-To-The-Upload-Widget-v2-0)
- [Applying transformations on Upload](https://cloudinary.com/documentation/transformations_on_upload)
- [Cloudinary Upload Widget Live Demo Customizer](https://demo.cloudinary.com/uw/#/)
- [Full Docs for upload Widget including the signed upload guidelines](https://cloudinary.com/documentation/upload_widget)
- [Image transformation options for cropping and resizing](https://cloudinary.com/documentation/resizing_and_cropping)
- [Image Transformation docs](https://cloudinary.com/documentation/image_transformations)
- [Preparing upload parameters](https://cloudinary.com/documentation/upload_widget#prepare_upload_parameters)